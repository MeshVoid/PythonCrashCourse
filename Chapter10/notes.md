# Chapter 10
# Files and Exceptions

This chapter is devoted to the data analysis and working with files. We will learn about _exceptions_, how to handle errors so taht your programs don't crash when they encounter unexpected situations.

File handling will significantly improve your programs. They will be able to save their data, enter it and store it and then reuse it again, when they decide to run your program again. 

Learning to handle exceptions whill help your programs deal with situations when files are missing or don't exist and other problems that can cause your programs to crash.

## Reading from a file

Reading from a file is useful not only in data analysis, but when you want to modify, edit stored information in a file. You can write programs that could read the contents of a text file and edit the file with formatting that allows a browser to display it.

When you want to work with the data from a text file, first thing to do is to read the file into your computer's memory. You can read the entire contents of a file, or you can work through the file one line at a time.

## Reading an entire file

Here's a program that opens the file pi_digits.txt, reads it, and prints the contents of the file to the screen:
```python
#file_reader.py
with open('pi_digits.txt') as file_object: # Python assigns the file to file_object
    contents = file_object.read()
print(contents)
```
**open()** - open the file to access it. open() function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that's currently being executed is stored. 

**with** - keyword closes the file once access to it is no longer needed. Notice how we call open() in this program but not close(). You could open and close the file by calling open() and close(), but if a bug in your program prevents the close() method from being executed, the file may never close. Improperly closed files can cause data to be lost or corrupted, also if you call close() too early, you may try to work with a closed file that you don't have access to anymore, which will also lead to errors. That is why we use **with** and trust Python to close the file after the with block finished execution.

**read()** - once we have a file object that represents the text file we have indicated (pi_digits.txt), we use **read() method**  to read teh entire contents of the file and store it as one long string in contents. When we print the value of contents, we get the entire text file back.

The output would look like that:
>3.1415926535
>8979323846
>2643383279
The only difference between this output and the original file is the extra blank line at the end of the output. The blank line appears because **read()** method returns an empty string when it reaches the end of the file; this empty string shows up as a blank line.

If you want to remove the extra blank line, you can use rstrip() in the call to print():
```python
with open('pi_digits.txt') as file_object:
    contents = file_object.read()
print(contents.rstrip())
```

## File Paths

When you pass a simple filename like _pi\_digits.txt_ to the **open()** function, Python looks in the diretory where the file that's currently being executed (that is, your .py program file) is stored.

Sometimes, depending on how you organize your work, the file you want to open won't be in the same directory as your program file. 

You could use a relative file path to open a file:
> with open('text_files/filename.txt) as file_object

you can also tell Python exactly where the file is on your computer regardless of where the program that's being executed is stored. This is called _absolute file path_. Because absolute paths are usually longer than relative paths, it is helpful to assing them to a variable and then pass that variable to **open()**:

```python
file_path = "/home/user/other_files/text_files/filename.txt"
with open(file_path) as file_object:
```

Using absolute paths, you can read files from any location on your system. 

_If you try to use backslashes in a file path, you’ll get an error because the backslash is used to escape characters in strings. For example, in the path "C:\path\to\file.txt", the sequence \t is interpreted as a tab. If you need to use backslashes, you can escape each one in the path, like this: "C:\\path\\to\\file.txt"._

## Reading Line by line

You can use a for loop on the file object to examine each line from a file one at a time:

```python
filename = 'Chapter10/pi_digits.txt'

with open(filename) as file_object:
    for line in file_object:
        print(line.rstrip()) # user rstrip() to get rid of extra lines generated by print function
```

## Making a list of lines from a file

When you use with, the file object returned by open() is only available inside the with block that contains it. If you want to retain access to a file's contents outside the with block, you can store the file's lines in a list inside the block and then work with that list. 
You can process parts of the file immediately and postpone some processing for later in the program.

```python

filename = 'Chapter10/pi_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines() # readlines() take each line from the file and store it in a list.

    for line in lines: # print each line from lines.
        print(line.rstrip())
```

## Working with a file's contents

After you've read a file into memory, you can do whatever you want with that data, so let's brifly explore the digits of _pi_.

First, we will build a single string containing all the digits in the file with no witespace in it:

```python
filename = 'Chapter10\pi_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines()

pi_string = '' # create a varible to hold the digits of pi
for line in lines: # create a loop to add each line of digits to pi_string
    pi_string += line.rstrip() # and remove character from each line

print(pi_string) # print the string
print(len(pi_string))
```

_When Python reads from a text file, it interprets all text in the file as a string. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the int() function or convert it to a float using the float() function._

## Large files: one million digits

The code that we have written in our examples so far would work just as well on much larger files. 

```python
filename = 'Chapter10\pi_million_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines()

pi_string = '' # create a varible to hold the digits of pi
for line in lines: # create a loop to add each line of digits to pi_string
    pi_string += line.rstrip() # and remove character from each line

print(f"{pi_string[:52]}...") # print the string
print(len(pi_string))
```
Python has no inherent limit to how much data you can work with; you can work with as much data as your system’s memory can handle.


## Is your birthday contained in pi?

I've always been curious to know if my birthday appears anywhere in the digits of _pi_. Let's write a program that will find out if someones birthday appears anywhere in the first million digits of _pi_.

```python
filename = 'Chapter10\pi_million_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines()


pi_string = '' # create a varible to hold the digits of pi
for line in lines: # create a loop to add each line of digits to pi_string
    pi_string += line.rstrip() # and remove character from each line

birthday = input("Enter your birthday, in the form mmddyy: ")
if birthday in pi_string:
    print("Your birthday appears in the first million digits of pi!")
else:
    print("Your birthday does not appear in the first million digits of pi.")
```